// helloworld.cxx  单行注释

/** info:多行注释*/
import <iostream>;   // info: 模块导入,  无 重复导入的弊端


int main(int argc, char* argv[])
{
	std::cout << "Hello World !" << std::endl;
	std::cout << "There are" << 219 << " ways i love you" << std::endl;   // 输出流在一行中 连续输出 多个不同类型的数据 

	std::cout << std::format("There are {} ways i love you", 219) << std::endl;  // 输出流 C++20后推荐写法  定义格式化的字符串
	//std::println("Hello, World!");    // 该函数还未 重写为模块函数, 暂时注释
	return 0;
}

/**

cd build.ninja 
rm -rf *
cmake .. -G Ninja  
cmake --build . -G 11

*/

/**

 				[[01 注释]]
  单行注释, 多行注释  无需阐述 



 				[[02 模块导入]] 
  C++20 新特性  替代之前的 头文件机制 ; 
  若使用 某个模块中的功能 , 需 导入该模块, import语句

  若 编译器 还不支持 模块, 就 使用 原来的 头文件机制 #include预处理指令 即可
  LLVM/Clang 支持的速度慢一些, 最快的是MSVC 微软家的编译器 




 				[[03 预处理指令]]
 
 生成 C++程序 基础步骤  :  预处理  ->  编译 --> 链接 ; 

 预处理器 会 识别代码中的 元信息,  代码被编译成 计算机可识别的目标文件,  独立的目标文件 被 连接在一起 生成 一个 应用程序 ; 

 预处理指令 以 # 开头

 头文件机制 : 声明在其他地方定义的函数.  
 函数声明:  通知编译器 如何调用这个函数 , 并声明 函数的中的参数的个数 和 类型,以及 函数的返回类型; 
 函数定义: 可以理解函数的实现,  包含这个函数的实际代码 
 函数签名:  函数名  + 参数类型 , 不包含 函数返回类型; 

 头文件机制中  函数声明 通常放在 扩展名是.h 或 .hxx文件中, 称为 头文件;   函数实现/函数定义  通常放在 扩展名是 .cxx 或  .cpp文件中 ; 

 但 有了模块 后 , 无需 声明 和 定义分离; 

 模块的引入 一定是 解决 头文件机制 的部分问题,但 又会 引入 新的问题 这个要明白的 ;

 头文件 无法 解析, 导致 重复引入, 编译时间长,且 无法语法解析,安全性低等问题 ; 


 #include [file]--> 将指定的文件 插入代码中 指令所在的位置  -> 基本总是用来 包含头文件, 可使 代码 可使用 在其他位置定义的 功能  

 #define  [id] [value]  --> 每个指定的标识符都被替换为指定的值   --> C中 是 定义常数 或 宏 ;  C++中 基本不用,因为 有风险,  C++本身提供常数 和 大多数 宏类型

 #ifdef [id]   --> 代码被有条件的包含或舍弃 --> 经常 被用来 防止 循环包含 头文件弊病之一: 避免头文件被多次包含, 建议 如果是头文件的话,  #ifndef #define #endif 
 #endif 
 #ifndef [id]
 #endif 

#paragma  [xyz]  --> 因 编译器而异, 若在 预处理期间执行到 , 通常会显示一条警告或错误信息




						[[04 main函数]]
int类型是 指示 程序的最终执行状态. 
main() 函数 要么没有参数,要么就 具有 2个参数   int main(int argc, char* argv[])  

argc : 传递给程序的实参数目, 
argv : 传递给程序的实参   argv[0]  可能是 程序的 名称, 也可能是 空字符串, 基本不适用 它; 基本 使用 特定于平台的功能检索程序名 ;  

实际参数 从 索引1 开始 ;  



					[[05 输入输出流]]
std::cout  --> 用户控制台或标准输出的滑槽  ; 
std::cerr  --> 输出 错误信息  
std::endl  --> 序列结尾, 输出流 遇到 std::endl 会将 已送入滑槽中的数据  全部输出并 进行下一行 ; -->  当前缓冲区中的所有内容刷出滑槽并插入新的一行

\n 表示下一行,但不输出;  


不建议 过度使用std::endl :  影响程序性能 

<< 运算符 将数据 放入滑槽 

输出流:  可在 一行代码中 连续输出多个不同类型的数据 


输入流: 慎重对待 用户的输入 ;  
std::cin --> 输入流接收用户的 键盘输入; 

printf() 和  scanf() 未 提供 类型安全, 一般不建议使用 ;  

*/